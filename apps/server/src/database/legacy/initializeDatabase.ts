/**
 * Database initialization script that uses the ecommerce.sql file.
 * The SQL file now contains all necessary safety checks.
 */
import fs from "fs";
import path from "path";
import { Pool } from "pg";
import { env } from "../utils/env";

/**
 * Split SQL into separate statements for better error handling.
 */
function splitSqlStatements(sql: string): string[] {
  const statements: string[] = [];
  let currentStatement = "";
  let inPlPgSql = false;
  const lines = sql.split("\n");

  for (const line of lines) {
    const trimmedLine = line.trim();
    if (trimmedLine.startsWith("--") || trimmedLine === "") continue;
    if (line.includes("$$")) inPlPgSql = !inPlPgSql;
    currentStatement += line + "\n";
    if (trimmedLine.endsWith(";") && !inPlPgSql) {
      statements.push(currentStatement.trim());
      currentStatement = "";
    }
  }
  if (currentStatement.trim()) statements.push(currentStatement.trim());
  return statements.filter((stmt) => stmt.length > 0);
}

function findSqlFile(): string | null {
  const srcFilePath = path.resolve(
    process.cwd(),
    "src",
    "database",
    "ecommerce.sql"
  );
  if (fs.existsSync(srcFilePath)) return srcFilePath;
  const dirRelativePath = path.resolve(
    __dirname,
    "..",
    "..",
    "src",
    "database",
    "ecommerce.sql"
  );
  if (fs.existsSync(dirRelativePath)) return dirRelativePath;
  return null;
}

function getFallbackSchema(): string {
  return `
    CREATE TABLE IF NOT EXISTS "users" (
      "user_id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      "username" varchar(255) UNIQUE NOT NULL,
      "email" varchar(255) UNIQUE NOT NULL,
      "password_hash" varchar(255) NOT NULL,
      "role" varchar(255) NOT NULL DEFAULT 'user'
    );
    CREATE TABLE IF NOT EXISTS refresh_tokens (
      id SERIAL PRIMARY KEY,
      user_id INTEGER REFERENCES users(user_id) ON DELETE CASCADE,
      token TEXT NOT NULL,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
    CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token ON refresh_tokens (token);
  `;
}

/**
 * Initialize the database schema using the ecommerce.sql file.
 * @param pool PostgreSQL connection pool
 */
export async function initializeDatabase(pool: Pool): Promise<void> {
  console.log("\nüåüüóÑÔ∏è  [DB INIT] Let's get your database ready!");

  try {
    const sqlFilePath = findSqlFile();
    let sqlContent: string;

    if (sqlFilePath) {
      console.log(
        `üìú  Using SQL file: \x1b[36m${path.basename(sqlFilePath)}\x1b[0m`
      );
      sqlContent = fs.readFileSync(sqlFilePath, "utf8");
    } else {
      console.log("‚ö°Ô∏è  No SQL file found, using fallback schema.");
      sqlContent = getFallbackSchema();
    }

    const statements = splitSqlStatements(sqlContent);
    console.log(
      `üß©  Preparing to execute \x1b[33m${statements.length}\x1b[0m SQL statements...`
    );

    const client = await pool.connect();

    try {
      await client.query("BEGIN");
      let completed = 0;
      for (let i = 0; i < statements.length; i++) {
        try {
          await client.query({
            text: statements[i] as string,
            rowMode: "array",
          });
          completed++;
        } catch (error) {
          console.error(`üí•  Error in statement ${i + 1}:`, error);
          throw error;
        }
      }
      await client.query("COMMIT");
      console.log(
        `üéä‚ú®  Database schema initialized: ${completed}/${statements.length} statements executed successfully! üöÄ\n`
      );
    } catch (error) {
      await client.query("ROLLBACK");
      console.error("üõë  Transaction rolled back due to error.");
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("üö®  Failed to initialize database schema:", error);
    throw error;
  }
}
