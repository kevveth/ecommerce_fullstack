/**
 * Database initialization script that uses the ecommerce.sql file
 * The SQL file now contains all necessary safety checks
 */
import fs from "fs";
import path from "path";
import { Pool } from "pg";
import { env } from "../utils/env";

/**
 * Split SQL into separate statements for better error handling
 * @param sql The SQL content to split
 * @returns An array of individual SQL statements
 */
function splitSqlStatements(sql: string): string[] {
  // Split on semicolons but preserve PL/pgSQL blocks with $$ delimiters
  const statements: string[] = [];
  let currentStatement = "";
  let inPlPgSql = false;

  // Split the SQL by lines to handle PL/pgSQL blocks
  const lines = sql.split("\n");

  for (const line of lines) {
    // Skip comments and empty lines
    const trimmedLine = line.trim();
    if (trimmedLine.startsWith("--") || trimmedLine === "") {
      continue;
    }

    // Check if we're entering or exiting a PL/pgSQL block
    if (line.includes("$$")) {
      inPlPgSql = !inPlPgSql;
    }

    currentStatement += line + "\n";

    // If we hit a semicolon and we're not inside a PL/pgSQL block, we have a complete statement
    if (trimmedLine.endsWith(";") && !inPlPgSql) {
      statements.push(currentStatement.trim());
      currentStatement = "";
    }
  }

  // Add any remaining statement
  if (currentStatement.trim()) {
    statements.push(currentStatement.trim());
  }

  return statements.filter((stmt) => stmt.length > 0);
}

/**
 * Find the SQL file using a simpler and more reliable approach
 * @returns The path to the SQL file or null if not found
 */
function findSqlFile(): string | null {
  // For a simple and reliable approach, prioritize the source SQL file
  const srcFilePath = path.resolve(
    process.cwd(),
    "src",
    "database",
    "ecommerce.sql"
  );

  if (fs.existsSync(srcFilePath)) {
    return srcFilePath;
  }

  // If running from a compiled context (e.g., production), check the __dirname relative path
  const dirRelativePath = path.resolve(
    __dirname,
    "..",
    "..",
    "src",
    "database",
    "ecommerce.sql"
  );

  if (fs.existsSync(dirRelativePath)) {
    return dirRelativePath;
  }

  return null;
}

/**
 * Create a simple inline SQL schema if the file can't be found
 * This ensures the app can still start even without the SQL file
 * @returns SQL content for basic schema
 */
// Added comments to fallback SQL schema for clarity
function getFallbackSchema(): string {
  return `
    -- Users table
    CREATE TABLE IF NOT EXISTS "users" (
      "user_id" INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      "username" varchar(255) UNIQUE NOT NULL,
      "email" varchar(255) UNIQUE NOT NULL,
      "password_hash" varchar(255) NOT NULL,
      "role" varchar(255) NOT NULL DEFAULT 'user'
    );

    -- Basic refresh tokens table
    CREATE TABLE IF NOT EXISTS refresh_tokens (
      id SERIAL PRIMARY KEY,
      user_id INTEGER REFERENCES users(user_id) ON DELETE CASCADE,
      token TEXT NOT NULL,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );

    -- Create basic index
    CREATE INDEX IF NOT EXISTS idx_refresh_tokens_token ON refresh_tokens (token);
  `;
}

/**
 * Initialize the database schema using the ecommerce.sql file
 * @param pool PostgreSQL connection pool
 */
export async function initializeDatabase(pool: Pool): Promise<void> {
  console.log("Initializing database schema...");

  try {
    // Try to find the SQL file using the simplified approach
    const sqlFilePath = findSqlFile();

    // Get SQL content either from file or fallback
    let sqlContent: string;

    if (sqlFilePath) {
      console.log(`Found SQL file at: ${sqlFilePath}`);
      sqlContent = fs.readFileSync(sqlFilePath, "utf8");
    } else {
      console.warn("SQL file not found. Using fallback minimal schema.");
      sqlContent = getFallbackSchema();
    }

    // Split into statements for better error handling
    const statements = splitSqlStatements(sqlContent);
    console.log(`Found ${statements.length} SQL statements to execute`);

    const client = await pool.connect();

    try {
      // Begin transaction
      await client.query("BEGIN");

      // Execute each statement separately for better error reporting
      for (let i = 0; i < statements.length; i++) {
        const statement = statements[i];
        if (!statement || statement.length === 0) {
          continue;
        }

        try {
          // Use text parameter to ensure proper parsing of the SQL
          await client.query({
            text: statement,
            rowMode: "array", // Use array mode for better compatibility with complex statements
          });

          console.log(`Successfully executed statement #${i + 1}`);
        } catch (error) {
          console.error(`Error executing SQL statement #${i + 1}:`, error);
          throw error;
        }
      }

      // Commit transaction
      await client.query("COMMIT");
      console.log("Database schema initialized successfully");
    } catch (error) {
      // Rollback on error
      await client.query("ROLLBACK");
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error("Failed to initialize database schema:", error);
    throw error;
  }
}
